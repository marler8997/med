pub fn tokenize(row_str: []const u8, start: usize) struct {
    kind: highlight.TokenKind,
    end: usize,
} {
    var tokenizer = zigtokenizer.Tokenizer{ .buffer = row_str, .index = start };
    const token = tokenizer.next();
    std.debug.assert(token.loc.start >= start);
    switch (token.tag) {
        .eof => {
            if (std.mem.indexOf(u8, row_str, "//")) |comment_start| {
                if (comment_start == 0) return .{ .kind = .comment, .end = row_str.len };
                return .{ .kind = .unknown, .end = comment_start };
            }
        },
        else => {},
    }
    return .{ .kind = tokenKindFromZig(token.tag), .end = token.loc.end };
}

fn tokenKindFromZig(tag: zigtokenizer.Token.Tag) highlight.TokenKind {
    return switch (tag) {
        .invalid,
        .invalid_periodasterisks,
        .identifier,
        => .todo,
        .string_literal,
        .multiline_string_literal_line,
        .char_literal,
        => .string_literal,
        .eof => .unknown,
        .builtin => .keyword,
        .bang,
        .pipe,
        .pipe_pipe,
        .pipe_equal,
        .equal,
        .equal_equal,
        .equal_angle_bracket_right,
        .bang_equal,
        .l_paren,
        .r_paren,
        .semicolon,
        .percent,
        .percent_equal,
        .l_brace,
        .r_brace,
        .l_bracket,
        .r_bracket,
        .period,
        .period_asterisk,
        .ellipsis2,
        .ellipsis3,
        .caret,
        .caret_equal,
        .plus,
        .plus_plus,
        .plus_equal,
        .plus_percent,
        .plus_percent_equal,
        .plus_pipe,
        .plus_pipe_equal,
        .minus,
        .minus_equal,
        .minus_percent,
        .minus_percent_equal,
        .minus_pipe,
        .minus_pipe_equal,
        .asterisk,
        .asterisk_equal,
        .asterisk_asterisk,
        .asterisk_percent,
        .asterisk_percent_equal,
        .asterisk_pipe,
        .asterisk_pipe_equal,
        .arrow,
        .colon,
        .slash,
        .slash_equal,
        .comma,
        .ampersand,
        .ampersand_equal,
        .question_mark,
        .angle_bracket_left,
        .angle_bracket_left_equal,
        .angle_bracket_angle_bracket_left,
        .angle_bracket_angle_bracket_left_equal,
        .angle_bracket_angle_bracket_left_pipe,
        .angle_bracket_angle_bracket_left_pipe_equal,
        .angle_bracket_right,
        .angle_bracket_right_equal,
        .angle_bracket_angle_bracket_right,
        .angle_bracket_angle_bracket_right_equal,
        .tilde,
        => .operator,
        .number_literal,
        .doc_comment,
        .container_doc_comment,
        => .doc_comment,
        .keyword_addrspace,
        .keyword_align,
        .keyword_allowzero,
        .keyword_and,
        .keyword_anyframe,
        .keyword_anytype,
        .keyword_asm,
        .keyword_async,
        .keyword_await,
        .keyword_break,
        .keyword_callconv,
        .keyword_catch,
        .keyword_comptime,
        .keyword_const,
        .keyword_continue,
        .keyword_defer,
        .keyword_else,
        .keyword_enum,
        .keyword_errdefer,
        .keyword_error,
        .keyword_export,
        .keyword_extern,
        .keyword_fn,
        .keyword_for,
        .keyword_if,
        .keyword_inline,
        .keyword_noalias,
        .keyword_noinline,
        .keyword_nosuspend,
        .keyword_opaque,
        .keyword_or,
        .keyword_orelse,
        .keyword_packed,
        .keyword_pub,
        .keyword_resume,
        .keyword_return,
        .keyword_linksection,
        .keyword_struct,
        .keyword_suspend,
        .keyword_switch,
        .keyword_test,
        .keyword_threadlocal,
        .keyword_try,
        .keyword_union,
        .keyword_unreachable,
        .keyword_usingnamespace,
        .keyword_var,
        .keyword_volatile,
        .keyword_while,
        => .keyword,
    };
}

const std = @import("std");
const highlight = @import("../highlight.zig");
const zigtokenizer = @import("zigtokenizer.zig");
